# make和Makefile介绍

## 程序的编译和链接

### 程序的编译和链接过程
当编写C语言程序时，需要将源代码转换为可执行程序的过程包括编译和链接两个主要阶段。下面是以GCC编译器为例的程序的编译和链接过程：

1. 预处理（Preprocessing）：
   在编译过程开始之前，预处理器会处理源代码文件（以`.c`为扩展名）。它执行包括宏展开、头文件包含、条件编译等任务。预处理器会根据包含的头文件和宏定义进行文本替换，生成一个被称为预处理后的源代码文件（通常以`.i`或`.ii`为扩展名）。

2. 编译（Compilation）：
   在这一阶段，编译器会将预处理后的源代码文件转换为汇编语言代码文件（以`.s`为扩展名），即将C语言代码转化为特定机器平台上的汇编指令。编译器负责检查语法错误和类型错误，并进行相应的优化。

3. 汇编（Assembly）：
   汇编器（如GNU as）将汇编语言代码文件转换为目标文件（以`.o`为扩展名），其中包含了机器指令和数据。目标文件是二进制文件，仍然是机器相关的。

4. 链接（Linking）：
   在链接阶段，链接器（如GNU ld）将目标文件与所需的库文件进行合并，生成最终的可执行程序。链接器解决了符号引用的问题，它将不同目标文件中引用的函数和变量的定义连接在一起，生成一个可执行程序文件。链接器还负责处理库的链接，包括静态库和动态库。

在链接过程中，可能会涉及两种类型的链接：

- 静态链接（Static Linking）：
  在静态链接中，链接器会将所有被引用的库文件的代码和数据复制到最终的可执行文件中。这样，可执行文件就包含了所有所需的库的代码，可以独立运行，而不依赖于系统上是否存在相应的库文件。

- 动态链接（Dynamic Linking）：
  在动态链接中，可执行文件只包含对库函数的引用，而实际的库代码和数据存储在共享库文件中。在程序运行时，操作系统的动态链接器将库文件加载到内存，并将引用与实际地址进行关联，以完成链接。这样可以实现代码的共享，减小可执行文件的大小，并允许共享库的更新和替换。

GCC编译器将上述过程整合在一起，可以直接将源代码编译成最终的可执行程序。你可以使用GCC命令来进行整个编译和链接过程，例如：
```
gcc main.c -o program
```
其中，`main.c`

是源代码文件，`program`是生成的可执行程序的名称。

了解程序的编译和链接过程对于理解make和makefile的工作原理非常重要，因为make工具主要用于自动化构建过程，根据源代码的变化和依赖关系进行编译和链接。

### 分步编译和链接
当使用GCC编译器进行程序编译和链接时，可以将编译和链接过程分为两步来演示。我们将使用一个简单的C语言程序来进行示例，包含两个源代码文件：`main.c`和`helper.c`。`main.c`文件包含程序的入口函数，`helper.c`文件包含一个辅助函数。

以下是演示编译和链接的步骤：

1. 编译（Compilation）：
   首先，我们使用GCC编译器将每个源代码文件编译为目标文件（`.o`文件），并生成对应的汇编代码（`.s`文件）。
   
   编译`main.c`文件：
   ```
   gcc -c main.c -o main.o
   ```
   
   编译`helper.c`文件：
   ```
   gcc -c helper.c -o helper.o
   ```
   
   这将生成`main.o`和`helper.o`两个目标文件。

2. 链接（Linking）：
   接下来，我们使用GCC编译器将目标文件链接在一起，生成最终的可执行程序。

   链接目标文件生成可执行程序：
   ```
   gcc main.o helper.o -o program
   ```

   这将生成名为`program`的可执行文件。

完成上述步骤后，你将得到一个名为`program`的可执行程序，可以通过执行`./program`来运行它。

需要注意的是，上述示例中的程序较简单，只包含两个源文件。对于更复杂的项目，可能涉及多个源文件和库文件，并可能需要更复杂的编译和链接规则。在这种情况下，使用make和makefile来自动化构建过程会更加方便和灵活。


### 来个例子吧

- 我需要给学生展示：写个c语言源代码，然后手动编译，一步一步的编译连接生成可执行程序这个过程。使用msys2，mingw64工具链。

当然，我可以帮你完成这个任务。以下是一个示例的C语言源代码，以及一步一步的编译连接过程，使用MSYS2和MinGW-w64工具链。

首先，你需要安装MSYS2和MinGW-w64。你可以从官方网站下载并按照说明进行安装。

然后，创建一个名为 `hello.c` 的文本文件，将以下代码复制并粘贴进去：

```c
#include <stdio.h>

int main() {
    printf("Hello, World!\n");
    return 0;
}
```

保存并关闭文件。

接下来，打开MSYS2终端，进入你保存 `hello.c` 文件的目录。

执行以下命令来安装所需的编译工具：

```
pacman -S mingw-w64-x86_64-toolchain
```

安装完成后，执行以下命令来编译 `hello.c` 文件：

```
gcc -o hello hello.c
```

这将使用GCC编译器将 `hello.c` 文件编译为可执行文件 `hello.exe`。

最后，执行以下命令来运行可执行文件：

```
./hello
```

终端将输出 `Hello, World!`。

这就是使用MSYS2和MinGW-w64工具链编译和运行C语言程序的过程。你可以将这些步骤展示给学生，让他们了解C语言程序的编译和执行过程。

- 先编译到汇编代码，然后编译到目标代码，再连接，分步展示。
非常抱歉，我误解了你的要求。下面是一个逐步展示编译到汇编代码、编译到目标代码，以及连接的过程。

假设你已经按照之前提到的步骤安装了MSYS2和MinGW-w64工具链。接下来，我们将使用以下C语言源代码作为示例，并命名为 `hello.c`：

```c
#include <stdio.h>

int main() {
    printf("Hello, World!\n");
    return 0;
}
```

请按照以下步骤逐步编译、连接和运行代码：

**步骤 1: 编译到汇编代码**

在MSYS2终端中，进入 `hello.c` 文件所在的目录。

执行以下命令，将C源代码编译为汇编代码：

```bash
gcc -S -o hello.s hello.c
```

这将生成一个名为 `hello.s` 的汇编代码文件。

**步骤 2: 编译到目标代码**

继续执行以下命令，将汇编代码编译为目标代码：

```bash
gcc -c -o hello.o hello.s
```

这将生成一个名为 `hello.o` 的目标代码文件。

**步骤 3: 连接生成可执行程序**

最后，执行以下命令将目标代码文件连接起来生成可执行程序：

```bash
gcc -o hello hello.o
```

这将生成一个名为 `hello` 的可执行文件。

**步骤 4: 运行程序**

执行以下命令运行可执行程序：

```bash
./hello
```

终端将输出 `Hello, World!`。

通过按照以上步骤，你可以逐步展示将C语言源代码编译到汇编代码，再编译到目标代码，最后连接生成可执行程序的过程。学生可以观察每个阶段生成的文件，以及最终的输出结果。
- 请使用分立的两个源文件，便于理解连接。

当然，我理解了你的要求。下面是一个示例，使用两个分离的源文件来展示编译、汇编、目标代码生成以及连接的过程。

首先，创建一个名为 `main.c` 的文件，包含以下代码：

```c
#include <stdio.h>

extern void printHello();

int main() {
    printHello();
    return 0;
}
```

接下来，创建一个名为 `hello.c` 的文件，包含以下代码：

```c
#include <stdio.h>

void printHello() {
    printf("Hello, World!\n");
}
```

现在，我们将逐步展示编译、汇编、目标代码生成和连接的过程。请按照以下步骤进行：

**步骤 1: 编译到汇编代码**

在MSYS2终端中，进入包含 `main.c` 和 `hello.c` 文件的目录。

执行以下命令，将 `main.c` 编译为汇编代码 `main.s`：

```bash
gcc -S -o main.s main.c
```

执行以下命令，将 `hello.c` 编译为汇编代码 `hello.s`：

```bash
gcc -S -o hello.s hello.c
```

**步骤 2: 汇编到目标代码**

继续执行以下命令，将 `main.s` 和 `hello.s` 文件汇编为目标代码：

```bash
gcc -c -o main.o main.s
gcc -c -o hello.o hello.s
```

这将生成 `main.o` 和 `hello.o` 两个目标代码文件。

**步骤 3: 连接生成可执行程序**

最后，执行以下命令将 `main.o` 和 `hello.o` 文件连接起来生成可执行程序：

```bash
gcc -o hello main.o hello.o
```

这将生成一个名为 `hello` 的可执行文件。

**步骤 4: 运行程序**

执行以下命令运行可执行程序：

```bash
./hello
```

终端将输出 `Hello, World!`。

通过按照以上步骤，你可以展示将两个分离的源文件编译为汇编代码，然后汇编为目标代码，并最终将它们连接为可执行程序的过程。这将帮助学生更好地理解连接的概念和过程。

### 小结一下

不论是C还是C++，通常我们首先将源文件编译成中间代码文件，Windows下为.obj文件，UNIX下为.o文件，也被称为目标文件（Object File）。这个过程称为编译（compile）。然后，我们将大量的目标文件链接在一起，生成可执行文件，这个过程称为链接（link）。

在编译阶段，编译器需要确保语法的正确性以及函数和变量的声明正确。对于后者，通常需要告诉编译器头文件的位置（头文件中应该只包含声明，而定义应放在C/C++文件中）。只要所有语法正确，编译器就能生成中间目标文件。一般来说，每个源文件对应一个中间目标文件（.o文件或.obj文件）。

在链接阶段，主要是链接函数和全局变量。因此，我们可以使用这些中间目标文件（.o文件或.obj文件）来链接我们的应用程序。链接器不关心函数所在的源文件，只关心函数的中间目标文件（Object File）。通常情况下，由于源文件较多，编译生成的中间目标文件也很多，而在链接时需要明确指出中间目标文件的名称，这对编译非常不方便。因此，我们需要将中间目标文件打包。在Windows下，这种打包方式称为“库文件”（Library File），即.lib文件；而在UNIX下，称为Archive File，即.a文件。

总结一下，源文件首先会生成中间目标文件，然后使用这些中间目标文件生成可执行文件。在编译阶段，编译器只检查程序的语法和函数、变量的声明。如果函数未被声明，编译器会给出警告，但仍可以生成Object File。而在链接阶段，链接器会在所有的Object File中寻找函数的实现。如果找不到，就会报告链接错误（Linker Error）。在VC（Visual C++）下，这种错误通常为Link 2001错误，表示链接器无法找到函数的实现。你需要指定函数的Object File。

## make和Makefile

### 为什么需要make和Makefile
如果我们的程序依赖成千上万的源代码，而且分布在不同的目录，我们能不能自动化的进行我们程序的构建？我们修改了某个文件，依赖这个文件的所有文件都应该重新编译，而不依赖它的文件应该不需要重新编译。有没有工具实现这一点？

当然有了。Makefile是一个用于自动化构建过程的文件，它定义了源代码文件的编译规则和依赖关系。尽管Windows的集成开发环境（IDE）通常会为程序员处理这些工作，但了解Makefile对于成为一名优秀和专业的程序员仍然很重要，就像了解HTML标签对于成为一名专业的前端开发人员一样。

特别是在Unix系统下的软件编译过程中，你不能不自己编写Makefile。会不会编写Makefile从某种程度上反映了一个人是否具备完成大型工程的能力，因为Makefile涉及整个工程的编译规则。在一个工程中，源文件数量众多，按照类型、功能和模块分别存放在多个目录中。Makefile定义了一系列规则，指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至可以执行更复杂的功能操作，因为Makefile就像一个Shell脚本，可以执行操作系统命令。

Makefile的好处在于实现了"自动化编译"。一旦编写完成，只需要运行一个make命令，整个工程将完全自动编译，大大提高了软件开发的效率。make是一个命令工具，用于解释Makefile中的指令。通常情况下，大多数集成开发环境都提供了make命令，例如Delphi的make、Visual C++的nmake，以及Linux下的GNU make。因此，Makefile已成为工程编译的一种常用方法。

不同厂商的make工具语法各有不同，但它们的本质都是在处理"文件依赖性"。下面将主要介绍GNU make，因为它是应用最广泛、使用最多的make工具，并且符合IEEE 1003.2-1992标准（POSIX.2）。我们将以C/C++源码为基础，涉及一些与C/C++编译相关的知识。关于这方面的内容，请参考相关编译器的文档。

Makefile定义就是**依赖关系**和**生成规则**。为什么我们没有采用上文的**编译规则**。因为Makefile定义的是更广泛的生成规则，例如文件A从它所依赖的文件B如何生成出来，而不仅仅是程序源文件的编译。

### Makefile的一个例子
当涉及到分步编译和链接的过程时，Makefile可以帮助我们自动化这个过程。下面是一个简单的Makefile示例，展示了如何使用Makefile来编译和链接一个简单的C程序：

```makefile
# 定义编译器和编译选项
CC = gcc
CFLAGS = -Wall -g

# 定义目标文件和依赖关系
TARGET = myprogram
OBJS = main.o utils.o

# 默认目标，即执行make命令时的默认动作
all: $(TARGET)

# 链接目标文件生成可执行文件
$(TARGET): $(OBJS)
	$(CC) $(CFLAGS) $^ -o $@

# 编译每个源文件生成目标文件
%.o: %.c
	$(CC) $(CFLAGS) -c $< -o $@

# 清理生成的目标文件和可执行文件
clean:
	rm -f $(OBJS) $(TARGET)
```

在这个示例中，我们定义了以下几个内容：

1. `CC`：编译器的名称，这里使用gcc。
2. `CFLAGS`：编译选项，这里使用-Wall和-g，表示开启所有警告并生成调试信息。
3. `TARGET`：目标可执行文件的名称，这里设为myprogram。
4. `OBJS`：目标文件的名称列表，这里包括main.o和utils.o。

Makefile中的规则包括：

1. `all`：默认目标，执行make命令时的默认动作，依赖于$(TARGET)。
2. `$(TARGET)`：链接目标文件生成可执行文件，依赖于$(OBJS)。
3. `$(OBJS)`：编译每个源文件生成目标文件，依赖于对应的.c文件。
4. `%.o`：通配符规则，用于编译每个源文件。

最后，Makefile还包括了一个清理规则：

1. `clean`：用于删除生成的目标文件和可执行文件。

要使用这个Makefile，将其保存为名为"Makefile"（注意大小写）的文件，并将其与源文件放在同一目录下。然后在命令行中运行`make`命令即可自动编译和链接程序。如果需要清理生成的文件，可以运行`make clean`命令。

请注意，该示例中的Makefile只是一个简单的示例，实际项目中可能需要更复杂的Makefile来处理更多的源文件和依赖关系。

### 时间戳是Make和Makefile决定哪些文件需要重新构建的依据

时间戳是Make和Makefile决定哪些文件需要重新构建的依据之一。Make工具会比较目标文件和依赖文件的时间戳，根据时间戳的差异确定是否需要重新构建目标文件。

在Makefile中，每个目标都有一组依赖文件，表示生成该目标所需要的源文件或其他中间文件。当执行make命令时，Make会检查目标文件和依赖文件的时间戳，如果依赖文件的时间戳比目标文件的时间戳更新，或者目标文件不存在，那么Make就会执行相应的规则重新构建目标文件。

通过比较时间戳，Make可以避免无需重新构建的部分，从而提高编译的效率。只有在源文件或依赖文件发生了变化，或者目标文件不存在时，Make才会重新构建目标文件。

需要注意的是，时间戳并不是唯一的依据，Make还会根据文件的依赖关系、规则和命令等进行判断。但时间戳是其中一个重要的判断因素，用于确定哪些文件需要重新构建。

### make的一些变种
除了传统的Makefile，还有一些Makefile的变种工具，每个工具都有自己的特点和使用场景。下面是一些常见的Makefile变种工具：

1. QMake：QMake是Qt框架提供的一个构建工具。它使用一种简化的语法来描述项目的构建过程，并能够自动生成传统Makefile。QMake主要用于Qt项目的构建，可以跨平台使用。

2. NMake：NMake是微软提供的用于Windows平台的构建工具。它使用一种类似于Makefile的语法，并支持Windows平台上的命令和工具。NMake通常与Microsoft Visual Studio一起使用，用于构建Windows平台上的C/C++项目。

3. Wmake：WMake是OpenFOAM（开源计算流体力学软件）项目中自定义的构建工具，用于管理和构建OpenFOAM的源代码和应用程序。OpenFOAM是一个开源的数值计算软件库，用于模拟流体动力学问题。

4. CMake：CMake是一个跨平台的构建工具，它可以生成不同平台上的原生构建脚本（如Makefile、Visual Studio项目等）。CMake使用一种类似于脚本的语法描述项目的构建过程，并具有很高的可移植性和灵活性。CMake广泛应用于C/C++项目的构建。

这些变种工具都是为了简化和自动化项目的构建过程，并提供特定平台或框架的支持。根据项目的需求和开发环境的不同，可以选择合适的构建工具来管理和构建项目。

### 关于cmake再多说一点

CMake是一个跨平台的开源构建工具，用于管理和自动生成用于构建项目的原生构建脚本，例如Makefile、Visual Studio项目等。它旨在简化跨平台项目的构建过程，提供高度可移植性和灵活性。CMake使用一种名为CMakeLists.txt的文本文件来描述项目的构建规则。

CMakeLists.txt是CMake的配置文件，其中包含了项目的构建规则和指令。下面是一个简单的CMakeLists.txt示例：

```cmake
cmake_minimum_required(VERSION 3.12)  # 指定所需的最低CMake版本

project(MyProject)  # 设置项目名称

# 添加源文件
set(SOURCES
    src/main.cpp
    src/foo.cpp
    src/bar.cpp
)

# 添加可执行目标
add_executable(myapp ${SOURCES})

# 添加头文件搜索路径
include_directories(include)

# 添加链接库
target_link_libraries(myapp mylib)
```

在CMakeLists.txt中，首先使用`cmake_minimum_required`指令指定所需的最低CMake版本。然后使用`project`指令设置项目名称。

接下来，通过使用`set`指令定义一个变量（这里是`SOURCES`），用于存储源文件的路径。可以根据项目的实际情况添加更多的源文件。

使用`add_executable`指令创建一个可执行目标，将变量`SOURCES`中的源文件编译为可执行文件（这里是`myapp`）。

使用`include_directories`指令添加头文件搜索路径，以便编译器能够找到所需的头文件。

最后，使用`target_link_libraries`指令添加链接库（这里是`mylib`）到目标可执行文件。

CMakeLists.txt还支持其他各种指令和选项，可以根据项目的需求进行配置。CMake具有丰富的文档和社区支持，可以更深入地了解其功能和用法。

要构建项目，可以在命令行中使用CMake来生成适用于特定构建系统的构建文件（例如Makefile或Visual Studio项目），然后使用生成的构建文件来进行编译和构建。

总的来说，CMake提供了一种简洁而强大的方式来管理项目的构建过程，使得在不同平台和构建系统上的项目构建变得更加灵活和可维护。

**注意：CMake可以根据CMakeLists.txt生成Makefile或者Visual studio的项目文件。**

关于make和Makefile可以[参考这里获得更多的信息](https://seisman.github.io/how-to-write-makefile/index.html)。